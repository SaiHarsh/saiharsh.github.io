<!DOCTYPE html>
<html class="no-js">
    <head>
        <!-- Basic Page Needs
        ================================================== -->
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <link rel="icon" type="image/png" href="images/favicon.png">
        <title>GSoC-2018</title>
        <meta name="description" content="">
        <meta name="keywords" content="">
        <meta name="author" content="">
        <link rel="shortcut icon" type="image/x-icon" href="images/icon.png" />
        <!-- Mobile Specific Metas
        ================================================== -->
        <meta name="format-detection" content="telephone=no">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <!-- Template CSS Files
        ================================================== -->
        <!-- Twitter Bootstrs CSS -->
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <!-- Ionicons Fonts Css -->
        <link rel="stylesheet" href="css/ionicons.min.css">
        <!-- animate css -->
        <link rel="stylesheet" href="css/animate.css">
        <!-- Hero area slider css-->
        <link rel="stylesheet" href="css/slider.css">
        <!-- owl craousel css -->
        <link rel="stylesheet" href="css/owl.carousel.css">
        <link rel="stylesheet" href="css/owl.theme.css">
        <link rel="stylesheet" href="css/jquery.fancybox.css">
        <!-- template main css file -->
        <link rel="stylesheet" href="css/main.css">
        <!-- responsive css -->
        <link rel="stylesheet" href="css/responsive.css">
        
        <!-- Template Javascript Files
        ================================================== -->
        <!-- modernizr js -->
        <script src="js/vendor/modernizr-2.6.2.min.js"></script>
        <!-- jquery -->
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
        <!-- owl carouserl js -->
        <script src="js/owl.carousel.min.js"></script>
        <!-- bootstrap js -->

        <script src="js/bootstrap.min.js"></script>
        <!-- wow js -->
        <script src="js/wow.min.js"></script>
        <!-- slider js -->
        <script src="js/slider.js"></script>
        <script src="js/jquery.fancybox.js"></script>
        <!-- template main js -->
        <script src="js/main.js"></script>
          <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
          </script>
    </head>
    <body>
        <!--
        ==================================================
        Header Section Start
        ================================================== -->
        <header id="top-bar" class="navbar-fixed-top animated-header">
            <div class="container">
                <div class="navbar-header">
                    <!-- responsive nav button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    </button>
                    <!-- /responsive nav button -->
                    
                    <!-- logo -->
                    <div class="navbar-brand">
                        <a href="index.html" >
                            Sai Harsh Tondomker
                        </a>
                    </div>
                
                </div>
                <!-- main menu -->
                <nav class="collapse navbar-collapse navbar-right" role="navigation">
                    <div class="main-menu">
                        <ul class="nav navbar-nav navbar-right">
                            <li>
                                <a href="index.html" >Home</a>
                            </li>
<!--                             <li><a href="about.html">About Me</a></li>
                            <li><a href="projects.html">Projects</a></li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Experience <span class="caret"></span></a>
                                <div class="dropdown-menu">
                                    <ul>
                                        <li><a href="internship.html">Internship Page</a></li>
                                        <li><a href="gallery.html">Gallery</a></li>
                                    </ul>
                                </div>
                            </li> 
                            <li><a href="present.html">Present</a></li> -->
                            <li><a href="contact.html">Contact</a></li>
                        </ul>
                    </div>
                </nav>
                <!-- /main nav -->
            </div>
        </header>
        
        <!--
        ==================================================
        Slider Section Start
        ================================================== -->
        <br><br><br><br>
            <div class="container" role="main">
                <div class="row">
                    <br>
                    <div class="col-md-3"> 
                        <img src="images/GSoC/GSoC-2018.png" alt="" class="img-responsive">
                        
                    </div>
                    <div class="col-md-6 text-center">
                        <h2> Google Summer of Code 2018 </h2>
                        <h2> A Linear Time Implementation of SPQR-Trees </h2>
                        <p> 
                            This project is part of GSoC-2018. The objective of this project is to implement in Python the linear time algorithm first proposed by Hopcroft and Tarjan<a href="#Reference">[1]</a> and later corrected by Gutwenger and Mutzel<a href="#Reference">[2]</a> to decompose a (multi)graph into triconnected components and organize these components into a SPQR-tree. The code is to be integrated into SageMath graph library. This project has been conducted under the guidance of David Coudert and Dima Pasechnik. 
                        </p>
                    </div>
                    <div class="col-md-3"> 
                        <br>
                        <img src="images/GSoC/sagemath.jpg" alt="" class="img-responsive">
                    </div>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <h2> <b>The Journey <b></h2>
                            <ul >
                                <li>
                                    <h3> Getting started </h3>
                                </li>
                                <li>
                                    <p>In the initial weeks, to get a hands-on experience on sagemath development, I started working on <b><a href="https://trac.sagemath.org/ticket/25123">#25123</a></b>(Merged) which estimates the closeness centrality of the nodes in a graph.</p>
                                    <p>
                                        <i>Definition:</i> closeness centrality (or closeness) of a node in a connected undirected graph is calculated as the inverse of average of the shortest paths between the node to all other nodes in the graph. Thus the more central a node is, the closer it is to all other nodes.
                                    </p>
                                    <p>
                                        It was first defined by Bavelas (1950)<a href="#Reference">[3]</a>, on a connected undirected Graph G = (V, E), |V| = n = number of vertices , an inverse of <i>farness</i>, where farness is the inverse of average of the shortest paths from v to u \( \in  \) V. </p>
                                        <b> Algorithm: </b>
                                    </p>
                                </li>
                            </ul >
                            <ol>
                                <li> <p> \(S\) = k random vertices from n vertices of input graph G.  </p> </li>
                                <li> <p> Run k times BFS from the vertices in \(S\), which will give k*n distances.</p> </li>
                                <li> <p> For each vertex in \(S\), closeness centrality will be actual value, which is </p> </li> \( C^{-1}(v) = (n-1)/\sum\limits_{u \in V} d_{vu} \) 
                                <li> <p> For remaining n - k vertices we need to estimate the closeness centrality which is calculated as:</p> </li>
                                    \( C^{-1}(v) = k/\sum\limits_{u \in S} d_{vu} \)
                            </ol>
                    </div>
                    <div class="col-md-12">
                       <p> While implementing this algorithm in Python, we found that there is a scope to improve the reusablility of simple_bfs function, which leads to create the patch <b><a href="https://trac.sagemath.org/ticket/25223">#25223</a></b>(Merged), in which we made simple_bfs function more generic and updated all the functions which are dependent on simple_bfs function. By the end of these two patches, I got good exposure of sagemath code base.  </p>
                    </div>
                    <div class="col-md-12">
                        <ul >
                            <li><h3> Start working on SPQR-Tree </h3></li>                            
                        </ul>
                    <div class="col-md-12">
                         <p> Starting the coding part </p>
                        <p> We need to decide in which file we are supposed to add the function, this leads to create a new file connectivity.pyx, it includes all the functions from generic_graph.py / graph.py / digraph.py which uses cut vertices/cut edges. Ticket <b><a href="https://trac.sagemath.org/ticket/25436">#25436</a></b>(Merged) which is completed with the help of Meghana M Reddy. </p>
                        <p>
                            Before starting the main coding part, I worked on finalizing a longstanding open ticket <b><a href="https://trac.sagemath.org/ticket/22157">#22157</a></b>(Merged) on decomposing a graph into 3-vertex-connected components and constructing a SPQR tree. The idea is to use a method based on integer linear programming to find 2 vertex cuts of the graph, then construct the SPQR tree. Even though this method is not the best choice with respect to the computation time, it is not difficult to check the correctness of the code. 
                        </p>
                        <p>
                            The main motivation behind finalizing this ticket was to be able to compare the results of the method 1 & 2 and the correctness. </p>
                        <p> 
                            Below is the brief explanation of method 1.
                        </p>
                        <br>

                        <b> Method 1: Cleave </b>
                        <br> <br>
                        <p> Cleave: For a connected unweighted multi-graph G and a vertex cut X, it computes the list of subgraphs of \(G\) induced by each connected component \(c\) of \(G\setminus X\) plus \(X\), i.e., \(G[c\cup X]\) </p>
                        <ul >
                            <li> <p> It returns 3 list, </p> </li>
                            <li> <p> 1. S = List of connected component with cut vertices have virtual edges.</p> </li>
                            <li> <p> 2. C = is the graph of the cocycles, set of virtual edges created/added in connected components + one extra copy. </p> </li>
                            <li> <p>3. f = It's a graph with cut vertices and virtual edges. i.e the complement of the subgraph of ``G`` induced by cut vertices</p> </li>
                            <li> <p>Algorithm:</p> </li>
                            <li> <p> Input: Multi-Graph G, cut_vertex list </p> </li>
                            <li> <p> Output: S, C, f </p> </li>
                        </ul>
                        <ol >
                            <li> <p> If cut vertices are given, validate it else create a cut vertex list from graph G.</p> </li>
                            <li> <p> Find connected components after removing cut vertices from the cut vertex list.</p> </li>
                            <li> <p> To find virtual edges which are to be added, 
                            firstly find a subgraph with cut vertices then construct its complement graph which is f(virtual cut graph), all the edges f has will be added in the connected components, </p> </li>
                            <li> <p> For all connected components, construct a subgraph with connected component vertices + cut vertices after that add all the edges we found in step 3, this will give us S.</p> </li>
                            <li> <p> cocycles = no. of edges in f (step 3) * (no. of connected component in (step 4) + 1). </p> </li>
                        </ol>
                    </div>
                    <div class="col-md-12">
                        <p> This method is extended with allowing the user to disable adding of virtual edges in connected components, if virtual_edge==false then f is a graph with isolated cut vertices i.e independent set. </p>
                        <br>
                        Step 2: construction of SPQR-Tree using Cleave function as helper function.
                        <br> <br>
                        <p> <i>Definition</i>: The data structure SPQR-tree represents the decomposition of a biconnected graph with respect to its triconnected components.</p>
                        <p> The vertices of SPQR-Tree could be of 4 types given below.</p>
                        <ol >
                            <li> <p> S (Series) Type: A cyclic graph with atleast 3 vertices. </p> </li>
                            <li> <p> P (parallel) Type: A multi-graph with 2 vertices and multiple edges between them. </p> </li>
                            <li> <p> Q (Trivial case) Type: The associated graph has a single real edge. This trivial case is necessary to handle the graph that has only one edge. </p> </li>
                            <li> <p> R (Rigid) Type: A 3-connected component. </p> </li>
                        </ol>

                        <p> Algorithm: </p>
                        <p> Input: multi-graph G </p>
                        <p> Output: SPQR-Tree </p>
                        
                        <ol>
                            <li> <p> Find cut vertices of input multi-graph G. </p></li>
                            <li> <p> If G has multiple edges, construct a simple graph SG, and store all the multiple edges in counter, if (u, v) has 4 multiple edges between them, then all 4 will be present in counter. </p></li>
                            <li> <p> If SG is a cyclic graph then return SPQR-Tree with one vertex of S which has all the edges of SG, and create P type vertices from counter. </p></li>
                            <li> <p> If SG is not a cyclic graph, </p>
                            <p> create a queue push (SG, cut_vertices) </p>
                            <p> while queue is not empty</p>
                            <p> &emsp; B, B_cut = queue.pop()</p>
                            <p> &emsp; S, C, f = cleave(B, cut_vertices=B_cut)</p>
                            <p> &emsp; for each component in S, </p>
                            <p> &emsp; &emsp; if component is a cycle append in S_block, </p>
                            <p> &emsp; &emsp; else check if it's a 2-connected block then queue.push(component, it's cut vertices) </p>
                            <p> &emsp; &emsp; if not 2-connected block then push it to R_blocks list. </p></li>
                            <li> <p> create the P_block with the help of virtual edges which are added in S(step 4) </p> </li>
                            <li> <p> Creation of Tree: Create tree nodes from S_block, R_block and P_block. </p>
                            <p> &emsp; For each edge in counter_multiple_edges: </p>
                            <p> &emsp; &emsp; P_block = ('P', [e]*num) </p>
                            <p> &emsp; &emsp; &emsp;for all blocks in S & R: </p>
                            <p> &emsp; &emsp; &emsp; &emsp;if any block contains this edge, create an edge between Tree.add_edge(p_block, block) 
                            </p></li>
                        </ol>
                        <p>The second most important thing is to verify the output of our function, so we created a function which takes input as SPQR-Tree and outputs Graph H. If  H.is_isomorphic(G) ==True then SPQR-Tree is correct. </p>
                        <p> Algorithm: </p>
                        <ol>
                            <li> <p> Make two dictionary namely count_p and count_g. For all vertices in input SPQR-Tree, if the vertex has P or Q label, update count_p with edges and their count. similarly, for S and R label vertices, update count_g dict. </p></li>
                            <li> <p> Iterate over all the edges of count_g if that edge is available then num = count_p[edge] - count_g[e] and add num, no. of times edge in H. </p></li>
                            <li> <p> Now Iterate over all the edges in count_p and if that edge is not available in count_g, directly add that edge with it's respective count from count_p in H. </p></li>
                            <li> <p> Return H </p></li>
                        </ol>
                        <b> Method 2: Hopcroft_Tarjan<a href="#Reference">[1]</a> </b>
                        <br> <br>
                        <p> The linear time algorithm of SPQR-Tree is: </p>
                        <p> Input: Multi-Graph </p>
                        <p> output: SPQR-Tree </p>
                        <p> It consists of 4 modules </p>
                        <p> <b> Module 1:</b> Appending multiple edges from input graph G to respective
                        components (split_multi_egdes()), in this module a simple graph is constructed from the input graph and all the multiple edges are stored in components. </p>
                        <p> <b> Module 2:</b> Construction of an Acceptable Adjacency Structure, in this module an adjacency structure of the simple graph is constructed using lowpt1 and lowpt2<a href="#Reference">[2]</a> which are found using dfs1 traversal<a href="#Reference">[2]</a>. </p>
                        <p> <b> Module 3:</b> Finding Triconnected Components, in this module first we need to find separation pairs from the split components<a href="#Reference">[2]</a>, in which we label the pair which is type-1 or type-2<a href="#Reference">[2]</a>. After finding separation pair find triconnected components using those points. </p>
                        <p> <b> Module 4:</b> Construction of SPQR-Tree, after finding triconnected components which is the most challenging part, construction of tree becomes easier, connect all the components(tree vertices) using virtual edges, one virtual edge will connect two components(two tree vertices). </p>
                        <p> Module 1 & 4 are done by me  and remaining Module 2 and Module 3 are done by Meghana M Reddy.  </p>
                        <p> The output of the code is tested by spqrtree_to_graph function i.e which is developed in method 1. Method 1 mostly act as verification code for method 2. Method 2 running time is in linear order which is better than method 1. </p>
                        <p> The complete work of method 2 is done in ticket <b><a href="https://trac.sagemath.org/ticket/25598">#25598</a></b>, it's in the process of getting merge. </p>

                        <h2> <b> Conclusion: </b> </h2>
                        <p> This project is the first open-source python implementation of static SPQR-Tree in linear time, the extension of this work could be the implementation of dynamic SPQR-Tree/cythonizing the implementation of method 2 or it's application on planar graph embedding. </p>

                        <h2> <b> GSoC Experience: <b></h2>
                        <p>
                            It was a great experience working with SageMath, I learnt how one should code/write the comments such that if anyone is going to use/modify my work should spend the least time in understanding it. Not only this, it gave me an opportunity to explore how actually open source organization works. I am grateful that I got this opportunity. My mentors David Coudert and Dima Pasechnik were very supportive not only in giving guidance but also helpful in coding side.
                        </p>
                        <h2> <b> Acknowledgment: </b></h2>
                        <p>
                            I would like to take this opportunity to thank my mentors David Coudert and Dima Pasechnik for their invaluable support during the course of the project. The work on patches could not have been possible without their support. At last, I would like to thank GSOC for providing the platform for students to be active in open source development. It is through gsoc that I found out about SageMath and got the opportunity to contribute to it.
                        </p>

                        <div id="Reference"><a href="Reference"></a><h3> <b> Reference: </b></h3></div>

                        <p>[1] J. E. Hopcroft, R. E. Tarjan: Dividing a Graph into Triconnected Components. SIAM J. Comput. 2(3): 135-158 (1973) </p>
                        <p>[2] C. Gutwenger, P. Mutzel: A Linear Time Implementation of SPQR-Trees. Graph Drawing 2000: 77-90 </p>
                        <p>[3] Edith Cohen, Daniel Delling, Thomas Pajor, and Renato F. Werneck.   Computing classic closeness centrality, at scale. CoRR, abs/1409.0035, 2014.</p>
                    </div>  

                </div>
            </div>
           

 
            <!--
            ==================================================
            Footer Section Start
            ================================================== -->
            <footer id="footer">
                <div class="container">
                    <div class="col-md-8">
                        <p class="copyright">Copyright: <span>2017</span> . Design and Developed by <a href="index.html">Sai Harsh Tondomker</a></p>
                    </div>
                    <div class="col-md-4">
                        <!-- Social Media -->
                        <ul class="social">
                            <li>
                                <a href="https://www.facebook.com/sai.harsh.9" class="Facebook">
                                    <i class="ion-social-facebook"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://www.linkedin.com/in/saiharsh-tondomker-179497a5/" class="Linkedin">
                                    <i class="ion-social-linkedin"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://plus.google.com/u/0/+SaiHarshTondomker" class="Google Plus">
                                    <i class="ion-social-googleplus"></i>
                                </a>
                            </li>
                           <li>
                                <a href="https://github.com/SaiHarsh" class="Github">
                                    <i class="ion-social-github"></i>
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>
            </footer> <!-- /#footer -->
                
        </body>
    </html>
